    Create a another class variable: Matrix  _screenScaleMatrixInverse;      Set  _screenScaleMatrixInverse = Matrix.Invert(_screenScaleMatrix);
     in UpdateScreenScaleMatrix() after the matrix is updated.  The mouse position Vector2 is _mousePosition = Vector2.Transform(new Vector2(_ms.X,_ms.Y),_screenScaleMatrixInverse);
      Where _ms is the current MouseState. You may need to Add the centering adjustments from the viewport(may depend on the platform).    
    
    
    
    just dotnet watch and edit and save your files ( hot reload)
    or use your ideâ€™s integration
    
    // Static means shared across all instances of a class, but we're only going to have one instance of
    // City scene, does this indicate anything? Don't want to overuse 
    
        /// <summary>
        /// Expression-bodied properties:
        /// The => lambda syntax creates read-only computed properties using expression body syntax(introduced in C# 6.0). These properties:
        /// Have no setter (read-only)
        /// Calculate their values on-demand based on the underlying fields
        /// Are essentially shorthand for { get { return _cursorPosX* CityTileSize; } }
        /// </summary>

//// ------------------- 09/04 --------------------------
    - Cannot set source file for texture coordinates by state?
    - How to reference Iconcategory in Gum


// ------------------- 09/04 --------------------------

Navigation - global world scale for zoom with scroll wheel?
	- Maybe boot up monkey city web to see how it functions
		-  ive only played the mobile game so idk how it would look on the desktop
	- How to highlight current city block


	- Stack panel on right side for towers, drag and drop 
		- Eligibility check 

	- Ui on click associated with each tile? maybe instead a 


Basically UI is gonna be a whole fuckin university course.
	- Start with the basics can flesh them out later
		- So far I'm attempting to link the code from the snake tutorial with the code generated from the project (with and without .gumx project linked)
		- Going to ask around in the Monogame discord for more advanced resources / examples of project source code


/ -------------------------
Camera mechanic in main city. 

// APPROACH 1 - fucked it up last time in other project

public class Camera

	Matrix Follow(Rectangle target, Vector2 screenSize) 

		return Matrix(-target) // Use matrix transform in spritebatch -> translation matrix on tilemap according to (reverse) player input.
		// Or just do _spriteBatch.Begin(TranslationMatrix = -matrix)
		//   - this is more elegant, but it might be better practice to try to only have one (or as little spritebatch begins and ends as possible)
		//       -> Just apply translation on Tilemap (and gameobjects) draw vector?. Consider interaction with UI.
	
/ -------------------------

Keyboard navigation of city? - mouse necessity?

ToDo:

	- Try to have a building project with a working rudimentary title screen and city screen and associated scene classes. Can view city with basic tilemap layout
	- Figure out event handling to process screen transitions + work with tilemap.

Later on:
	- Dragging and dropping buildings, towers etc....










{
    public static class Drawing
    {
        public static GraphicsDeviceManager graphics;
        public static SpriteBatch spriteBatch;


        public static int width { get; private set; }
        public static int height { get; private set; }

        public static string title = "Monogame Test Project";

        public static bool vsych { get; private set; } = true;

        public static float dt, fps;

        //dummy texture
        public static Texture2D rect;

        public static void Initialize(Game1 g)
        {
            width = 1280;
            height = 720;
            graphics = new GraphicsDeviceManager(g);
            graphics.PreferredBackBufferWidth = width;
            graphics.PreferredBackBufferHeight = height;
            graphics.SynchronizeWithVerticalRetrace = vsych;
            graphics.ApplyChanges();

            spriteBatch = new SpriteBatch(g.GraphicsDevice);


        }

        public static void Update(GameTime gameTime, Game1 g)
        {
            dt = (float)gameTime.ElapsedGameTime.TotalSeconds;
            fps = (float) (1 / dt);
        }
    }


}
